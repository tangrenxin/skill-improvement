******************************  工厂方法模式（Factory Method Pattern）  *******************************
简单工厂vs.工厂方法
   简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了
与具体产品的依赖。就像前面的计算器例子，让客户端不用管改用哪个类的实例，只需要吧"+"给工厂，工厂自动就给出了相应的实例，客
户端只要去做运算就可以了，不同的实例会实现不同的运算。但问题就在这里，如果新加一个"求M数的N次方"的功能，我们是一定需要给
运算工厂类的方法里添加"Case"的分支条件的，修改原有的类？这就等于说，我们不但对扩展开放了，对修改也开放了，这就违背了开放-
封闭原则，于是，就有了工厂方法模式。

工厂方法模式（Factory Method Pattern）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化
延迟到其子类。工厂方法模式是简单工厂模式的进一步抽象和推广，克服了简单工厂模式既开放扩展，又开放修改的问题的缺点。但工厂方
法模式的缺点是由于每加一个产品，就需要添加一个产品工厂的类，增加了额外的开发量。

    以计算器实例为例，用工厂方法模式实现后，具体使用哪一种计算方法的逻辑被转移到了客户端，所以当增加计算方法时，就避免不了
修改客户端的代码，那么如何才能解决这个问题呢？（利用"反射"技术可以解决避免分支判断的问题，后期学习跟进）



