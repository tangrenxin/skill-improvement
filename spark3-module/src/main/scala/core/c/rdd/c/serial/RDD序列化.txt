RDD序列化
1、闭包检查
    从计算的角度，[算子以外的代码都是在Driver端执行，算子里面的代码都是在Executor端执行}。那么在scala的函数式编程中，
就会[导致算子内经常会用到算子外的数据，这样就形成了闭包的效果]，如果使用的算子外的数据无法序列化，就意味着无法传值给
Executor端执行，就会发生错误，所以需要在执行任务计算前，检测闭包内的对象是否可以进行序列化，这个操作我们称之为闭包检测。

2、序列化方法和属性
    从计算的角度，算子以外的代码都是在Driver端执行，算子里面的代码都是在Executor端执行。

3、Kryo序列化框架
    java的序列化能够序列化任何的类。但是比较重（字节多），序列化后，对象的提交也比较大。spark出于性能的考虑，Spark2.0
开始支持另外一种Kryo序列化机制、Kryo速度是Serializable的十倍。当RDD在shuffle数据的时候，简单的数据类型、数组和字符
串类型已经在Spark内部使用Kryo来序列化。

注意：即使使用Kryo序列化，也要继承Serializable接口。
java的序列化和kryo序列化的区别：p91