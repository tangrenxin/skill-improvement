== 乱序数据的测试流程 ==

-- [40,50）窗口的数据
83.149.9.216 - - 17/05/2015:10:05:49 +0000 GET /presentations/

-- [50,60）窗口的数据
- 这条数据来时，watermark = 50 - 1 = 49，还没有关闭窗口[40,50）
83.149.9.216 - - 17/05/2015:10:05:50 +0000 GET /presentations/

- 这条数据来时，watermark = 51 - 1 = 50，窗口[40,50）还没有关闭，因为允许1分钟的迟到数据，
- 触发窗口的计算操作，aggStream 有输出
- 但排序信息：resultStream没有输出，因为定时器设置的时间为windowEnd+1=51
83.149.9.216 - - 17/05/2015:10:05:51 +0000 GET /presentations/

- 这条数据来时，watermark = 52 - 1 = 51，窗口[40,50）还没有关闭，因为允许1分钟的迟到数据
- 触发窗口的计算操作，aggStream 有输出
- 排序信息：resultStream 输出
83.149.9.216 - - 17/05/2015:10:05:52 +0000 GET /presentations/

==============  以上是窗口触发计算输出热门页面统计的测试
====> 接下来来测试一下数据乱序的情况

- 这条数据来时，属于[40,50）窗口的迟到数据，因为设置了允许迟到1分钟内的数据参与计算
所以数据来时，会在原来的窗口计算结果之上进行聚合，aggStream 有输出
但排序信息：resultStream没有输出，因为排序数据的输出是靠定时器控制的，
这个窗口的定时器之前已经触发过一次，这条数据来了之后，会重新注册一个之前的定时器，
那问题来了，这条数据来之前，watermark=51,数据来了并注册定时器之后，
watermark(51)>windowEnd(50)，为什么没有触发排序输出呢？
如果注册的是一个已经过时的定时器，定时器不会立即出发，而是要等新的wm来时，再出发
就是说，定时器的触发必须依赖新的watermark，才能推进它触发
83.149.9.216 - - 17/05/2015:10:05:46 +0000 GET /presentations/

-- 什么时候 再次触发呢？
这条数据来时，比之前52的数据还要新，watermark得到推进，
此时，aggStream 没有输出，因为这条数据属于[50,60），还没有触发窗口计算操作
resultStream 有输出，因为上一条再次注册的定时器在新的wm到来之后就触发，输出排序数据
83.149.9.216 - - 17/05/2015:10:05:53 +0000 GET /presentations/

-- 这条数据来之后，[30,40)
输出很多条 聚合结果 aggStream:
data> ApacheLogEvent(83.149.9.216,-,1431828331000,GET,/presentations/)
agg> PageViewCount(/presentations/,1431828350000,3)
agg> PageViewCount(/presentations/,1431828345000,1)
agg> PageViewCount(/presentations/,1431828340000,1)
agg> PageViewCount(/presentations/,1431828335000,1)
可以发现，输出时间戳是 35、40、45、50
之前 35、40、45 窗口是因为没有数据，所以没有输出，但现在数据 31 来了之后，尽管当前的wm=52，
wm之前的窗口都已经触发了计算，但程序允许迟到1分钟以内的数据再次参与聚合，
这时候，就会触发迟到数据的聚合操作，因此之前 聚合窗口触发的聚合计算得到的aggStream都输出(每五秒钟输出最近10分钟的数据)
83.149.9.216 - - 17/05/2015:10:05:31 +0000 GET /presentations/

-- 类似的，再来一条 23 的数据，现象跟前面类似
83.149.9.216 - - 17/05/2015:10:05:23 +0000 GET /presentations/

-- 54 来时，输出了很多 resultStream
这是因为 前面迟到的数据使得35、40、45窗口再次进行聚合计算，进而windowFunction中再次注册了定时器
当 54 来时，新的wm来了，触发定时器，输出 35、40、45 对应的 resultStream
83.149.9.216 - - 17/05/2015:10:05:54 +0000 GET /presentations/
输出：
窗口结束时间：2015-05-17 10:05:25.0
NO1: 	页面URL = /presentations/	热门度 = 1
==================================
窗口结束时间：2015-05-17 10:05:30.0
NO1: 	页面URL = /presentations/	热门度 = 1
==================================
窗口结束时间：2015-05-17 10:05:35.0
NO1: 	页面URL = /presentations/	热门度 = 2
NO2: 	页面URL = /presentations/	热门度 = 1
==================================
窗口结束时间：2015-05-17 10:05:40.0
NO1: 	页面URL = /presentations/	热门度 = 2
NO2: 	页面URL = /presentations/	热门度 = 1
==================================
窗口结束时间：2015-05-17 10:05:45.0
NO1: 	页面URL = /presentations/	热门度 = 2
NO2: 	页面URL = /presentations/	热门度 = 1
==================================
窗口结束时间：2015-05-17 10:05:50.0
NO1: 	页面URL = /presentations/	热门度 = 4
NO2: 	页面URL = /presentations/	热门度 = 3
==================================
可以发现，数据出现了问题：同一个页面的url，输出了两条数据，这不就刷榜了吗，显然这样的数据是不对的。
分析一下出现这个问题的原因：（以 10:05:35 窗口为例）
时间回到迟到数据31来之前，之前的定时器已经输出，ontimer()中清空了pageViewCountListState(代码：pageViewCountListState.clear())
pageViewCountListState 中没有数据
接下来连续两条迟到数据 31，23来了之后发生了什么？

31来了之后，触发延时数据聚合计算，计算完后进入WindowFunction，
调用processElement(),将聚合结果加入 pageViewCountListState ，注册已过时的定时器
注意，此时定时器不会立即触发，需要等到新的wm来了之后再触发。此时 pageViewCountListState 中有1条数据

23来了，跟31的流程一样...，此时 pageViewCountListState 中有2条数据
（这里面的两条数据，就是
NO1: 	页面URL = /presentations/	热门度 = 2
NO2: 	页面URL = /presentations/	热门度 = 1
出现的原因。）

54 来了，wm更新，定时器触发，对 pageViewCountListState 中的数据进行排序取topN，
自然就输出了两行url一样的排名数据
所以，需要优化我们的代码：）

=============================== 还有个侧输出流没有测试到，
程序允许 迟到 1 分钟的数据再次聚合，那我们加一条1分钟以前的数据看看结果
迟到的数据会被放到侧输出流
83.149.9.216 - - 17/05/2015:09:53:51 +0000 GET /presentations/
输出：
late> ApacheLogEvent(83.149.9.216,-,1431827631000,GET,/presentations/)


83.149.9.216 - - 17/05/2015:10:02:51 +0000 GET /presentations/