package com.b.project.b.networkflowAnalysis.c.UniqueVisitor

/**
 * @Description:
 * @Author: tangrenxin
 * @Date: 2021/11/28 下午8:14
 */
object Code02UniqueVisitor {
  /**
   * 在上一个例子中，我们把所有数据的userId都存在了窗口计算的状态里，在窗口收集数据的过程中，状态会不断增大。
   * 一般情况下，只要不超出内存的承受范围，这种做法也没什么问题，但如果我们的数据量非常大呢？
   *
   * 把所有数据暂存放到内存里，显然不是一个好主意。我们会想到利用redis这种内存级k-v数据库为我们做一个缓存。
   * 但如果我们遇到的情况非常极端，数据量大到惊人呢？比如上亿级用户，要去重计算UV。
   *
   * 如果放到redis中，亿级用户id(每个20字节左右的话)可能需要几G甚至几十G的空间来存储。当然放到redis中，用集群进行扩展
   * 也不是不可以，但是明显代价太大了。
   *
   * 一个更好的想法是，其实我们不需要完整地存储用户id的信息，只要知道它在不在就行了。所以其实我们可以进行压缩处理，
   * 用一位（bit）就可以表示一个用户状态。这个思想的具体实现就是布隆过滤器(Bloom Filter)
   *
   * 注意的点：hash碰撞问题（如何解决hash碰撞问题）
   * 1.hash函数要取好一点
   * 2.bitmap要做得稀疏一点(比如，我有1亿个数，我用一个2亿个位的bitmap来存储这1亿个数)
   */

}
